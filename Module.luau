local Settings = ...

if type(Settings) ~= "table" then
  return nil
end

local _ENV = (getgenv or getrenv or getfenv)()

local VirtualInputManager: VirtualInputManager = game:GetService("VirtualInputManager")
local CollectionService: CollectionService = game:GetService("CollectionService")
local ReplicatedStorage: ReplicatedStorage = game:GetService("ReplicatedStorage")
local TeleportService: TeleportService = game:GetService("TeleportService")
local RunService: RunService = game:GetService("RunService")
local Players: Players = game:GetService("Players")

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local GunValidator: RemoteEvent = Remotes:WaitForChild("Validator2")
local CommF: RemoteFunction = Remotes:WaitForChild("CommF_")
local CommE: RemoteEvent = Remotes:WaitForChild("CommE")

local ChestModels = workspace:WaitForChild("ChestModels")
local WorldOrigin = workspace:WaitForChild("_WorldOrigin")
local Characters = workspace:WaitForChild("Characters")
local SeaBeasts = workspace:WaitForChild("SeaBeasts")
local Enemies = workspace:WaitForChild("Enemies")
local Map = workspace:WaitForChild("Map")

local EnemySpawns = WorldOrigin:WaitForChild("EnemySpawns")
local Locations = WorldOrigin:WaitForChild("Locations")

local RenderStepped = RunService.RenderStepped
local Heartbeat = RunService.Heartbeat
local Stepped = RunService.Stepped
local Player = Players.LocalPlayer

local Data = Player:WaitForChild("Data")
local Level = Data:WaitForChild("Level")
local Fragments = Data:WaitForChild("Fragments")
local Money = Data:WaitForChild("Beli")

local Modules = ReplicatedStorage:WaitForChild("Modules")
local Net = Modules:WaitForChild("Net")

local EXECUTOR_NAME = string.upper(if identifyexecutor then identifyexecutor() else "NULL")
local IS_BLACKLISTED_EXECUTOR = table.find({"NULL", "XENO", "SWIFT", "JJSPLOIT"}, EXECUTOR_NAME)

local hookmetamethod = (not IS_BLACKLISTED_EXECUTOR and hookmetamethod) or (function(...) return ... end)
local sethiddenproperty = sethiddenproperty or (function(...) return ... end)
local setupvalue = setupvalue or (debug and debug.setupvalue)
local getupvalue = getupvalue or (debug and debug.getupvalue)

local BRING_TAG = _ENV._Bring_Tag or `b{math.random(80, 2e4)}t`
local KILLAURA_TAG = _ENV._KillAura_Tag or `k{math.random(120, 2e4)}t`

_ENV._Bring_Tag = BRING_TAG
_ENV._KillAura_Tag = KILLAURA_TAG

local Connections = {} do
  if _ENV.rz_connections then
    for _, Connection in ipairs(_ENV.rz_connections) do
      Connection:Disconnect()
    end
  end
  
  _ENV.rz_connections = Connections
end

local function GetEnemyName(string)
  return (string:find("Lv. ") and string:gsub(" %pLv. %d+%p", "") or string):gsub(" %pBoss%p", "")
end

local function GetCharacterHumanoid(Character)
  if Character:GetAttribute("IsBoat") or Character.Parent == SeaBeasts then
    local HealthValue = Character:FindFirstChild("Health")
    
    if HealthValue then
      return HealthValue
    else
      return Character:FindFirstChild("Humanoid"), true
    end
  else
    return Character:FindFirstChildOfClass("Humanoid")
  end
end

local function CheckPlayerAlly(__Player: Player): boolean
  if tostring(__Player.Team) == "Marines" and __Player.Team == Player.Team then
    return false
  elseif __Player:HasTag(`Ally{Player.Name}`) or Player:HasTag(`Ally{__Player.Name}`) then
    return false
  end
  
  return true
end

local function WaitChilds(Instance, ...)
  for _, ChildName in ipairs({...}) do
    Instance = Instance:WaitForChild(ChildName)
  end
  return Instance
end

local function FastWait(Seconds, Instance, ...)
  local Success, Result = pcall(function(...)
    for _, ChildName in ipairs({...}) do
      Instance = Instance:WaitForChild(ChildName, Seconds)
    end
    return Instance
  end, ...)
  
  return if (Success and Result) then Result else nil
end

local Module = {} do
  local SkillsDebounce = {}
  local CachedEnemies = {}
  local CachedBring = {}
  local CachedChars = {}
  local CachedTools = {}
  local Items = {}
  
  local placeId = game.PlaceId
  local HitBoxSize = Vector3.new(50, 50, 50)
  local SeaList = {"TravelMain", "TravelDressrosa", "TravelZou"}
  
  Module.Sea = (placeId == 2753915549 and 1) or (placeId == 4442272183 and 2) or (placeId == 7449423635 and 3) or 0
  
  Module.IsSuperBring = false
  Module.RemoveCanTouch = 0
  Module.AttackCooldown = 0.3
  Module.MaxLevel = 2800
  Module.Webhooks = false
  Module.JobIds = true
  
  Module.allMobs = { __RaidBoss = {}, __Bones = {}, __Elite = {}, __CakePrince = {} }
  Module.Progress = {}
  Module.SpawnedFruits = {}
  Module.BossesName = {}
  Module.EnemyLocations = {}
  Module.SpawnLocations = {}
  
  Module.FruitsId = {
    ["rbxassetid://15060012861"] = "Rocket-Rocket",
    ["rbxassetid://15057683975"] = "Spin-Spin",
    ["rbxassetid://15104782377"] = "Blade-Blade",
    ["rbxassetid://15105281957"] = "Spring-Spring",
    ["rbxassetid://15116740364"] = "Bomb-Bomb",
    ["rbxassetid://15116696973"] = "Smoke-Smoke",
    ["rbxassetid://15107005807"] = "Spike-Spike",
    ["rbxassetid://15111584216"] = "Flame-Flame",
    ["rbxassetid://15112469964"] = "Falcon-Falcon",
    ["rbxassetid://15100433167"] = "Ice-Ice",
    ["rbxassetid://15111517529"] = "Sand-Sand",
    ["rbxassetid://15111553409"] = "Dark-Dark",
    ["rbxassetid://15112600534"] = "Diamond-Diamond",
    ["rbxassetid://15100283484"] = "Light-Light",
    ["rbxassetid://15104817760"] = "Rubber-Rubber",
    ["rbxassetid://15100485671"] = "Barrier-Barrier",
    ["rbxassetid://15112333093"] = "Ghost-Ghost",
    ["rbxassetid://15105350415"] = "Magma-Magma",
    ["rbxassetid://15057718441"] = "Quake-Quake",
    ["rbxassetid://15100313696"] = "Buddha-Buddha",
    ["rbxassetid://15116730102"] = "Love-Love",
    ["rbxassetid://15116967784"] = "Spider-Spider",
    ["rbxassetid://14661873358"] = "Sound-Sound",
    ["rbxassetid://15100246632"] = "Phoenix-Phoenix",
    ["rbxassetid://15112215862"] = "Portal-Portal",
    ["rbxassetid://15116747420"] = "Rumble-Rumble",
    ["rbxassetid://15116721173"] = "Pain-Pain",
    ["rbxassetid://15100384816"] = "Blizzard-Blizzard",
    ["rbxassetid://15100299740"] = "Gravity-Gravity",
    ["rbxassetid://14661837634"] = "Mammoth-Mammoth",
    ["rbxassetid://15708895165"] = "T-Rex-T-Rex",
    ["rbxassetid://15100273645"] = "Dough-Dough",
    ["rbxassetid://15112263502"] = "Shadow-Shadow",
    ["rbxassetid://15100184583"] = "Control-Control",
    ["rbxassetid://15106768588"] = "Leopard-Leopard",
    ["rbxassetid://15482881956"] = "Kitsune-Kitsune",
    ["rbxassetid://11911905519"] = "Spirit-Spirit",
    ["rbxassetid://118054805452821"] = "Gas-Gas",
    ["rbxassetid://115276580506154"] = "Yeti-Yeti"
  }
  Module.Bosses = {
    -- Bosses Sea 1
    ["Saber Expert"] = {
      NoQuest = true,
      Position = CFrame.new(-1461, 30, -51)
    },
    ["The Saw"] = {
      RaidBoss = true,
      Position = CFrame.new(-690, 15, 1583)
    },
    ["Greybeard"] = {
      RaidBoss = true,
      Position = CFrame.new(-5043, 25, 4262)
    },
    ["The Gorilla King"] = {
      IsBoss = true,
      Level = 20,
      Position = CFrame.new(-1128, 6, -451),
      Quest = {"JungleQuest", CFrame.new(-1598, 37, 153)}
    },
    ["Bobby"] = {
      IsBoss = true,
      Level = 55,
      Position = CFrame.new(-1131, 14, 4080),
      Quest = {"BuggyQuest1", CFrame.new(-1140, 4, 3829)}
    },
    ["Yeti"] = {
      IsBoss = true,
      Level = 105,
      Position = CFrame.new(1185, 106, -1518),
      Quest = {"SnowQuest", CFrame.new(1385, 87, -1298)}
    },
    ["Vice Admiral"] = {
      IsBoss = true,
      Level = 130,
      Position = CFrame.new(-4807, 21, 4360),
      Quest = {"MarineQuest2", CFrame.new(-5035, 29, 4326), 2}
    },
    ["Swan"] = {
      IsBoss = true,
      Level = 240,
      Position = CFrame.new(5230, 4, 749),
      Quest = {"ImpelQuest", CFrame.new(5191, 4, 692)}
    },
    ["Chief Warden"] = {
      IsBoss = true,
      Level = 230,
      Position = CFrame.new(5230, 4, 749),
      Quest = {"ImpelQuest", CFrame.new(5191, 4, 692), 2}
    },
    ["Warden"] = {
      IsBoss = true,
      Level = 220,
      Position = CFrame.new(5230, 4, 749),
      Quest = {"ImpelQuest", CFrame.new(5191, 4, 692), 1}
    },
    ["Magma Admiral"] = {
      IsBoss = true,
      Level = 350,
      Position = CFrame.new(-5694, 18, 8735),
      Quest = {"MagmaQuest", CFrame.new(-5319, 12, 8515)}
    },
    ["Fishman Lord"] = {
      IsBoss = true,
      Level = 425,
      Position = CFrame.new(61350, 31, 1095),
      Quest = {"FishmanQuest", CFrame.new(61122, 18, 1567)}
    },
    ["Wysper"] = {
      IsBoss = true,
      Level = 500,
      Position = CFrame.new(-7927, 5551, -637),
      Quest = {"SkyExp1Quest", CFrame.new(-7861, 5545, -381)}
    },
    ["Thunder God"] = {
      IsBoss = true,
      Level = 575,
      Position = CFrame.new(-7751, 5607, -2315),
      Quest = {"SkyExp2Quest", CFrame.new(-7903, 5636, -1412)}
    },
    ["Cyborg"] = {
      IsBoss = true,
      Level = 675,
      Position = CFrame.new(6138, 10, 3939),
      Quest = {"FountainQuest", CFrame.new(5258, 39, 4052)}
    },
    
    -- Bosses Sea 2
    ["Don Swan"] = {
      RaidBoss = true,
      Position = CFrame.new(2289, 15, 808)
    },
    ["Cursed Captain"] = {
      RaidBoss = true,
      Position = CFrame.new(912, 186, 33591)
    },
    ["Darkbeard"] = {
      RaidBoss = true,
      Position = CFrame.new(3695, 13, -3599)
    },
    ["Diamond"] = {
      IsBoss = true,
      Level = 750,
      Position = CFrame.new(-1569, 199, -31),
      Quest = {"Area1Quest", CFrame.new(-427, 73, 1835)}
    },
    ["Jeremy"] = {
      IsBoss = true,
      Level = 850,
      Position = CFrame.new(2316, 449, 787),
      Quest = {"Area2Quest", CFrame.new(635, 73, 919)}
    },
    ["Fajita"] = {
      IsBoss = true,
      Level = 925,
      Position = CFrame.new(-2086, 73, -4208),
      Quest = {"MarineQuest3", CFrame.new(-2441, 73, -3219)}
    },
    ["Smoke Admiral"] = {
      IsBoss = true,
      Level = 1150,
      Position = CFrame.new(-5078, 24, -5352),
      Quest = {"IceSideQuest", CFrame.new(-6061, 16, -4904)}
    },
    ["Awakened Ice Admiral"] = {
      IsBoss = true,
      Level = 1400,
      Position = CFrame.new(6473, 297, -6944),
      Quest = {"FrostQuest", CFrame.new(5668, 28, -6484)}
    },
    ["Tide Keeper"] = {
      IsBoss = true,
      Level = 1475,
      Position = CFrame.new(-3711, 77, -11469),
      Quest = {"ForgottenQuest", CFrame.new(-3056, 240, -10145)}
    },
    
    -- Bosses Sea 3
    ["Cake Prince"] = {
      RaidBoss = true,
      Position = CFrame.new(-2103, 70, -12165)
    },
    ["Dough King"] = {
      RaidBoss = true,
      Position = CFrame.new(-2103, 70, -12165)
    },
    ["rip_indra True Form"] = {
      RaidBoss = true,
      Position = CFrame.new(-5333, 424, -2673)
    },
    ["Stone"] = {
      IsBoss = true,
      Level = 1550,
      Position = CFrame.new(-1049, 40, 6791),
      Quest = {"PiratePortQuest", CFrame.new(-449, 109, 5950)}
    },
    ["Hydra Leader"] = {
	 IsBoss = true,
	 Level = 1675,
	 Position = CFrame.new(5836, 1019, -83),
	 Quest = {"VenomCrewQuest", CFrame.new(5214, 1004, 761)}
	},
    ["Kilo Admiral"] = {
      IsBoss = true,
      Level = 1750,
      Position = CFrame.new(2904, 509, -7349),
      Quest = {"MarineTreeIsland", CFrame.new(2485, 74, -6788)}
    },
    ["Captain Elephant"] = {
      IsBoss = true,
      Level = 1875,
      Position = CFrame.new(-13393, 319, -8423),
      Quest = {"DeepForestIsland", CFrame.new(-13233, 332, -7626)}
    },
    ["Beautiful Pirate"] = {
      IsBoss = true,
      Level = 1950,
      Position = CFrame.new(5370, 22, -89),
      Quest = {"DeepForestIsland2", CFrame.new(-12682, 391, -9901)}
    },
    ["Cake Queen"] = {
      IsBoss = true,
      Level = 2175,
      Position = CFrame.new(-710, 382, -11150),
      Quest = {"IceCreamIslandQuest", CFrame.new(-818, 66, -10964)}
    },
    ["Longma"] = {
      NoQuest = true,
      Position = CFrame.new(-10218, 333, -9444)
    }
  }
  Module.Shop = {
    {"Frags", {{"Race Reroll", {"BlackbeardReward", "Reroll", "2"}}, {"Reset Stats", {"BlackbeardReward", "Refund", "2"}}}},
    {"Fighting Style", {
      {"Buy Black Leg", {"BuyBlackLeg"}},
      {"Buy Electro", {"BuyElectro"}},
      {"Buy Fishman Karate", {"BuyFishmanKarate"}},
      {"Buy Dragon Claw", {"BlackbeardReward", "DragonClaw", "2"}},
      {"Buy Superhuman", {"BuySuperhuman"}},
      {"Buy Death Step", {"BuyDeathStep"}},
      {"Buy Sharkman Karate", {"BuySharkmanKarate"}},
      {"Buy Electric Claw", {"BuyElectricClaw"}},
      {"Buy Dragon Talon", {"BuyDragonTalon"}},
      {"Buy GodHuman", {"BuyGodhuman"}},
      {"Buy Sanguine Art", {"BuySanguineArt"}}
      -- {"Buy Divine Art", {"BuyDivineArt"}}
    }},
    {"Ability Teacher", {
      {"Buy Geppo", {"BuyHaki", "Geppo"}},
      {"Buy Buso", {"BuyHaki", "Buso"}},
      {"Buy Soru", {"BuyHaki", "Soru"}},
      {"Buy Ken", {"KenTalk", "Buy"}}
    }},
    {"Sword", {
      {"Buy Katana", {"BuyItem", "Katana"}},
      {"Buy Cutlass", {"BuyItem", "Cutlass"}},
      {"Buy Dual Katana", {"BuyItem", "Dual Katana"}},
      {"Buy Iron Mace", {"BuyItem", "Iron Mace"}},
      {"Buy Triple Katana", {"BuyItem", "Triple Katana"}},
      {"Buy Pipe", {"BuyItem", "Pipe"}},
      {"Buy Dual-Headed Blade", {"BuyItem", "Dual-Headed Blade"}},
      {"Buy Soul Cane", {"BuyItem", "Soul Cane"}},
      {"Buy Bisento", {"BuyItem", "Bisento"}}
    }},
    {"Gun", {
      {"Buy Musket", {"BuyItem", "Musket"}},
      {"Buy Slingshot", {"BuyItem", "Slingshot"}},
      {"Buy Flintlock", {"BuyItem", "Flintlock"}},
      {"Buy Refined Slingshot", {"BuyItem", "Refined Slingshot"}},
      {"Buy Dual Flintlock", {"BuyItem", "Dual Flintlock"}},
      {"Buy Cannon", {"BuyItem", "Cannon"}},
      {"Buy Kabucha", {"BlackbeardReward", "Slingshot", "2"}}
    }},
    {"Accessories", {
      {"Buy Black Cape", {"BuyItem", "Black Cape"}},
      {"Buy Swordsman Hat", {"BuyItem", "Swordsman Hat"}},
      {"Buy Tomoe Ring", {"BuyItem", "Tomoe Ring"}}
    }},
    {"Race", {{"Ghoul Race", {"Ectoplasm", "Change", 4}}, {"Cyborg Race", {"CyborgTrainer", "Buy"}}}}
  }
  
  function EnableBuso()
    local Char = Player.Character
    if Settings.AutoBuso and Module.IsAlive(Char) and not Char:FindFirstChild("HasBuso") then
      if Char:HasTag("Buso") then
        Module.FireRemote("Buso")
      elseif Money.Value >= 25e3 then
        Module.FireRemote("BuyHaki", "Buso")
      end
    end
  end
  
  function GetToolByName(Name: string): Tool?
    local Cached = CachedTools[Name]
    
    if Cached and Cached.Parent and (Cached.Parent == Player.Character or Cached.Parent == Player.Backpack) then
      return Cached
    end
    
    local Character = Player.Character
    local Backpack = Player.Backpack
    
    if Character then
      local Tool = Character:FindFirstChild(Name) or Backpack:FindFirstChild(Name)
      if Tool then
        CachedTools[Name] = Tool
        return Tool
      end
    end
  end
  
  function GetToolMastery(Name: string): number?
    local Cached = CachedTools[Name]
    
    if Cached and Cached.Parent then
      return Cached:GetAttribute("Level")
    end
    
    local Tool = GetToolByName(Name)
    return Tool and Tool:GetAttribute("Level")
  end
  
  function VerifyTool(Name: string): boolean
    local Cached = CachedTools[Name]
    
    if Cached and Cached.Parent and (Cached.Parent == Player.Character or Cached.Parent == Player.Backpack) then
      return true
    end
    
    return GetToolByName(Name)
  end
  
  function VerifyToolTip(Type: string): Instance?
    local Cached = CachedTools[`Tip_{Type}`]
    
    if Cached and Cached.Parent then
      return Cached
    end
    
    for _, Tool in Player.Backpack:GetChildren() do
      if Tool:IsA("Tool") and Tool.ToolTip == Type then
        CachedTools[`Tip_{Type}`] = Tool
        return Tool
      end
    end
    
    if not Module.IsAlive(Player.Character) then
      return nil
    end
    
    for _, Tool in Player.Character:GetChildren() do
      if Tool:IsA("Tool") and Tool.ToolTip == Type then
        CachedTools[`Tip_{Type}`] = Tool
        return Tool
      end
    end
    
    return nil
  end
  
  function ToDictionary(Array: table): table
    local Dictionary = {}
    for _, String in ipairs(Array) do
      Dictionary[String] = true
    end
    table.clear(Array)
    return Dictionary
  end
  
  function Module.TravelTo(Sea: number?): (nil)
    if SeaList[Sea] then
      Module.FireRemote(SeaList[Sea])
    end
  end
  
  function Module.newCachedEnemy(Name, Enemy)
    CachedEnemies[Name] = Enemy
  end
  
  function Module.Rejoin(): (nil)
    task.spawn(TeleportService.TeleportToPlaceInstance, TeleportService, game.PlaceId, game.JobId, Player)
  end
  
  function Module.IsAlive(Character: Model?): boolean
    if Character then
      local Humanoid, NoCache = CachedChars[Character] or GetCharacterHumanoid(Character)
      
      if Humanoid then
        if NoCache ~= true and not CachedChars[Character] then
          CachedChars[Character] = Humanoid
        end
        
        return Humanoid[if Humanoid.ClassName == "Humanoid" then "Health" else "Value"] > 0
      end
    end
  end
  
  function Module.FireRemote(...): any
    return CommF:InvokeServer(...)
  end
  
  function Module.IsFruit(Part: BasePart): Instance?
    return (Part.Name == "Fruit " or Part:GetAttribute("OriginalName")) and Part:FindFirstChild("Handle")
  end
  
  function Module.IsBoss(Name: string): boolean
    return Module.Bosses[Name] and true
  end
  
  function Module.UseSkills(Target: any?, Skills: table?): (nil)
    if Player:DistanceFromCharacter(Target.Position) >= 60 then
      return nil
    end
    
    for Skill, Enabled in Skills do
      local Debounce = SkillsDebounce[Skill]
      
      if Enabled and (not Debounce or (tick() - Debounce) >= 1) then
        VirtualInputManager:SendKeyEvent(true, Skill, false, game)
        VirtualInputManager:SendKeyEvent(false, Skill, false, game)
        SkillsDebounce[Skill] = tick()
      end
    end
  end
  
  function Module.KillAura(Distance: number?, Name: string?): (nil)
    Distance = Distance or 500
    
    local EnemyList = Enemies:GetChildren()
    
    for i = 1, #EnemyList do
      local Enemy = EnemyList[i]
      local PrimaryPart = Enemy.PrimaryPart
      
      if (not Name or Enemy.Name == Name) and PrimaryPart and not Enemy:HasTag(KILLAURA_TAG) then
        if Module.IsAlive(Enemy) and Player:DistanceFromCharacter(PrimaryPart.Position) < Distance then
          Enemy:AddTag(KILLAURA_TAG)
        end
      end
    end
  end
  
  function Module.IsSpawned(Enemy)
    local Cached = Module.SpawnLocations[Enemy]
    
    if Cached and Cached.Parent then
      return Cached:GetAttribute("Active") or Module:GetEnemyByTag(Enemy)
    end
    
    return Module:GetEnemyByTag(Enemy)
  end
  
  function Module:IsBlacklistedExecutor()
    return IS_BLACKLISTED_EXECUTOR
  end
  
  function Module:ServerHop(MaxPlayers: number?, Region: string?): (nil)
    MaxPlayers = MaxPlayers or self.SH_MaxPlrs or 8
    -- Region = Region or self.SH_Region or "Singapore"
    
    local ServerBrowser = ReplicatedStorage.__ServerBrowser
    
    for i = 1, 100 do
      local Servers = ServerBrowser:InvokeServer(i)
      for id,info in pairs(Servers) do
        if id ~= game.JobId and info["Count"] <= MaxPlayers then
          task.spawn(ServerBrowser.InvokeServer, ServerBrowser, "teleport", id)
        end
      end
    end
  end
  
  function Module:GetEnemy(Name: string): Instance?
    return self.EnemySpawned[Name]
  end
  
  function Module:GetClosestEnemy(Name: string): Instance?
    local Cached = CachedEnemies[Name]
    local Mobs = self.allMobs[Name]
    
    if self.IsAlive(Cached) or (not Mobs) then
      return Cached
    end
    
    local Position = (Player.Character or Player.CharacterAdded:Wait()):GetPivot().Position
    local Distance, Nearest = math.huge
    
    for i = 1, #Mobs do
      local Enemy = Mobs[i]
      local RootPart = Enemy.PrimaryPart
      
      if RootPart and self.IsAlive(Enemy) then
        local Magnitude = (RootPart.Position - Position).Magnitude
        
        if Magnitude < Distance then
          Distance, Nearest = Magnitude, Enemy
        end
      end
    end
    
    if Nearest then
      self.newCachedEnemy(Name, Nearest)
      return Nearest
    end
  end
  
  function Module:GetEnemyByList(List: table): Instance?
    for _, Name in List do
      local Cached = CachedEnemies[Name]
      
      if self.IsAlive(Cached) then
        return Cached
      end
      
      local Mobs = self.allMobs[Name]
      
      if Mobs then
        for _, Enemy in Mobs do
          if self.IsAlive(Enemy) then
            self.newCachedEnemy(Name, Enemy)
            return Enemy
          end
        end
      end
    end
  end
  
  function Module:BringEnemies(ToEnemy: Instance, SuperBring: boolean?): (nil)
    if not self.IsAlive(ToEnemy) or not ToEnemy.PrimaryPart then
      return nil
    end
    
    pcall(sethiddenproperty, Player, "SimulationRadius", math.huge)
    
    if Settings.BringMobs then
      Module.IsSuperBring = if SuperBring then true else false
      
      local Name = ToEnemy.Name
      local Position = (Player.Character or Player.CharacterAdded:Wait()):GetPivot().Position
      local Target = ToEnemy.PrimaryPart.CFrame
      local BringPositionTag = if SuperBring then "ALL_MOBS" else Name
      
      if not CachedBring[BringPositionTag] or (Target.Position - CachedBring[BringPositionTag].Position).Magnitude > 25 then
        CachedBring[BringPositionTag] = Target
      end
      
      local EnemyList = if SuperBring then Enemies:GetChildren() else self.allMobs[Name]
      
      for i = 1, #EnemyList do
        local Enemy = EnemyList[i]
        if Enemy.Parent ~= Enemies or Enemy:HasTag(BRING_TAG) then continue end
        if not Enemy:FindFirstChild("CharacterReady") then continue end
        
        local PrimaryPart = Enemy.PrimaryPart
        if self.IsAlive(Enemy) and PrimaryPart then
          if (Position - PrimaryPart.Position).Magnitude < Settings.BringDistance then
            Enemy:AddTag(BRING_TAG)
          end
        end
      end
    else
      if not CachedBring[ToEnemy] then
        CachedBring[ToEnemy] = ToEnemy.PrimaryPart.CFrame
      end
      
      ToEnemy.PrimaryPart.CFrame = CachedBring[ToEnemy]
    end
  end
  
  function Module:GetRaidIsland(): Instance?
    if self.RaidIsland then
      return self.RaidIsland
    end
    
    for i = 5, 1, -1 do
      local Name = "Island " .. i
      for _, Island in ipairs(Locations:GetChildren()) do
        if Island.Name == Name and Player:DistanceFromCharacter(Island.Position) < 3500 then
          self.RaidIsland = Island
          return Island
        end
      end
    end
  end
  
  function Module:GetProgress(Tag, ...)
    local Progress = self.Progress
    local entry = Progress[Tag]
    
    if entry and (tick() - entry.debounce) < 1.6 then
      return entry.result
    end
    
    local result = self.FireRemote(...)
    
    if entry then
      entry.result = result
      entry.debounce = tick()
    else
      Progress[Tag] = {
        debounce = tick(),
        result = result
      }
    end
    
    return result
  end
  
  function Module:RemoveBoatCollision(Boat)
    local Objects = Boat:GetDescendants()
    
    for i = 1, #Objects do
      local BasePart = Objects[i]
      if BasePart:IsA("BasePart") and BasePart.CanCollide then
        BasePart.CanCollide = false
      end
    end
  end
  
  Module.EnemySpawned = setmetatable({}, {
    __index = function(self, index)
      return Module:GetClosestEnemy(index)
    end,
    __call = function(self, index)
      if type(index) == "table" then
        return Module:GetEnemyByList(index)
      end
      
      local Cached = CachedEnemies[index]
      
      if Module.IsAlive(Cached) and Cached.PrimaryPart then
        return Cached
      end
      
      return self[index]
    end
  })
  
  Module.FruitsName = setmetatable({}, {
    __index = function(self, Fruit)
      local RealFruitsName = Module.FruitsId
      local Name = Fruit.Name
      
      if Name ~= "Fruit " then
        rawset(self, Fruit, Name)
        return Name
      end
      
      local Model = Fruit:WaitForChild("Fruit", 9e9)
      local Handle = FastWait(1, Model, "Fruit") or FastWait(1, Model, "Idle")
      
      if Handle and (Handle:IsA("Animation") or Handle:IsA("MeshPart")) then
        local IdProperty = if Handle:IsA("Animation") then "AnimationId" else "MeshId"
        local RealName = RealFruitsName[ Handle[IdProperty] ]
        
        if RealName and type(RealName) == "string" then
          rawset(self, Fruit, `Fruit [ {RealName} ]`)
          return rawget(self, Fruit)
        end
      end
      
      rawset(self, Fruit, "Fruit [ ??? ]")
      return "Fruit [ ??? ]"
    end
  })
  
  Module.MoonId = setmetatable({}, {
    __index = function(self, index)
      return Lighting.Sky.MoonTextureId == ("http://www.roblox.com/asset/?id=" .. index)
    end
  })
  
  Module.EquipTool = setmetatable({}, {
    __call = function(self, Name, byTip)
      local Char = Player.Character
      if Module.IsAlive(Char) then
        local Equipped = self.Equipped
        
        if Equipped and Equipped.Parent and Equipped[byTip and "ToolTip" or "Name"] == Name then
          if Equipped.Parent ~= Char then
            Char:WaitForChild("Humanoid"):EquipTool(Equipped)
          end
          return nil
        end
        
        if Name and not byTip then
          local Tool = Player.Backpack:FindFirstChild(Name)
          if Tool then
            self.Equipped = Tool
            Char:WaitForChild("Humanoid"):EquipTool(Tool)
          end
          return nil
        end
        
        local ToolTip = (byTip and Name) or Settings.FarmTool
        for _, Tool in Player.Backpack:GetChildren() do
          if Tool:IsA("Tool") and Tool.ToolTip == ToolTip then
            self.Equipped = Tool
            Char:WaitForChild("Humanoid"):EquipTool(Tool)
            break
          end
        end
      end
    end
  })
  
  Module.Chests = setmetatable({}, {
    __call = function(self, ...)
      if self.Cached and not self.Cached:GetAttribute("IsDisabled")  then
        return self.Cached
      end
      
      if self.Debounce and (tick() - self.Debounce) < 0.5 then
        return nil
      end
      
      local Position = (Player.Character or Player.CharacterAdded:Wait()):GetPivot().Position
      local Chests = CollectionService:GetTagged("_ChestTagged")
      
      if #Chests == 0 then
        return nil
      end
      
      local Distance, Nearest = math.huge
      
      for i = 1, #Chests do
        local Chest = Chests[i]
        local Magnitude = (Chest:GetPivot().Position - Position).Magnitude
        
        if not Chest:GetAttribute("IsDisabled") and Magnitude < Distance then
          Distance, Nearest = Magnitude, Chest
        end
      end
      
      self.Debounce = tick()
      self.Cached = Nearest
      return Nearest
    end
  })
  
  Module.Berry = setmetatable({}, {
    __call = function(self, BerryArray)
      local CachedBush = self.Cached
      
      if CachedBush then
        for Tag, CFrame in pairs(CachedBush:GetAttributes()) do
          return CachedBush
        end
      end
      
      if self.Debounce and (tick() - self.Debounce) < 0.5 then
        return nil
      end
      
      local Position = (Player.Character or Player.CharacterAdded:Wait()):GetPivot().Position
      local BerryBush = CollectionService:GetTagged("BerryBush")
      
      local Distance, Nearest = math.huge
      
      for i = 1, #BerryBush do
        local Bush = BerryBush[i]
        
        for AttributeName, BerryName in pairs(Bush:GetAttributes()) do
          if not BerryArray or table.find(BerryArray, BerryName) then
            local Magnitude = (Bush.Parent:GetPivot().Position - Position).Magnitude
            
            if Magnitude < Distance then
              Nearest, Distance = Bush, Magnitude
            end
          end
        end
      end
      
      self.Debounce = tick()
      self.Cached = Nearest
      return Nearest
    end
  })
  
  Module.PirateRaid = 0 do
    Module.PirateRaidEnemies = {}
    
    local Spawn = Vector3.new(-5556, 314, -2988)
    local BlackList = ToDictionary({ "rip_indra True Form", "Blank Buddy" })
    
    local IsPirateRaidEnemy = function(Enemy)
      local PrimaryPart = Enemy.PrimaryPart
      
      if Module.IsAlive(Enemy) and not BlackList[Enemy.Name] then
        if PrimaryPart and (PrimaryPart.Position - Spawn).Magnitude < 700 then
          table.insert(Module.PirateRaidEnemies, Enemy)
          Module.PirateRaid = tick()
        end
      end
    end
    
    table.insert(Connections, CollectionService:GetInstanceAddedSignal("BasicMob"):Connect(IsPirateRaidEnemy))
    for _, Mob in CollectionService:GetTagged("BasicMob") do IsPirateRaidEnemy(Mob) end
  end
  
  task.spawn(function()
    local allMobs = Module.allMobs
    
    local Elites = ToDictionary({ "Deandre", "Diablo", "Urban" })
    local Bones = ToDictionary({ "Reborn Skeleton", "Living Zombie", "Demonic Soul", "Posessed Mummy" })
    local CakePrince = ToDictionary({ "Head Baker", "Baking Staff", "Cake Guard", "Cookie Crafter" })
    
    function Module:GetClosestByTag(Tag)
      local Cached = CachedEnemies[Tag]
      local Mobs = allMobs[Tag]
      
      if Cached and Cached.Parent and self.IsAlive(Cached) then
        return Cached
      elseif not Mobs or #Mobs == 0 then
        return nil
      end
      
      local Position = (Player.Character or Player.CharacterAdded:Wait()):GetPivot().Position
      local Distance, Nearest = math.huge
      
      for _, Enemy in Mobs do
        local PrimaryPart = Enemy.PrimaryPart
        
        if PrimaryPart and self.IsAlive(Enemy) then
          local Magnitude = (Position - PrimaryPart.Position).Magnitude
          
          if Magnitude < 20 then
            CachedEnemies[Tag] = Enemy
            return Enemy
          elseif Magnitude < Distance then
            Distance, Nearest = Magnitude, Enemy
          end
        end
      end
      
      if Nearest then
        CachedEnemies[Tag] = Nearest
        return Nearest
      end
    end
    
    function Module:GetEnemyByTag(Tag)
      local Mobs = allMobs[Tag]
      if not Mobs then return end
      
      for i = 1, #Mobs do
        local Enemy = Mobs[i]
        
        if self.IsAlive(Enemy) then
          return Enemy
        end
      end
    end
    
    local function NewEnemyToList(Mobs, Enemy)
      local Humanoid = Enemy:WaitForChild("Humanoid", 10)
      
      if Humanoid.Health > 0 and not table.find(Mobs, Enemy) then
        table.insert(Mobs, Enemy)
        Humanoid.Died:Wait()
        table.remove(Mobs, table.find(Mobs, Enemy))
      end
    end
    
    local function MobAdded(Enemy)
      if not Enemy:IsA("Model") or not Enemy:GetAttribute("ID") or Enemy:GetAttribute("IsBoat") then
        return nil
      end
      
      local EnemyName = Enemy.Name
      local RaidBoss = Enemy:GetAttribute("RaidBoss")
      
      if RaidBoss then
        task.spawn(NewEnemyToList, allMobs.__RaidBoss, Enemy)
      elseif Elites[EnemyName] then
        task.spawn(NewEnemyToList, allMobs.__Elite, Enemy)
      elseif Bones[EnemyName] then
        task.spawn(NewEnemyToList, allMobs.__Bones, Enemy)
      elseif CakePrince[EnemyName] then
        task.spawn(NewEnemyToList, allMobs.__CakePrince, Enemy)
      end
      
      allMobs[EnemyName] = allMobs[EnemyName] or {}
      task.spawn(NewEnemyToList, allMobs[EnemyName], Enemy)
    end
    
    local function Bring(Enemy)
      local PlayerRootPart = (Player.Character or Player.CharacterAdded()):WaitForChild("HumanoidRootPart")
      local RootPart = Enemy:WaitForChild("HumanoidRootPart")
      local Humanoid = Enemy:WaitForChild("Humanoid")
      local EnemyName = Enemy.Name
      
      local BodyVelocity = Instance.new("BodyVelocity", RootPart)
      BodyVelocity.Velocity = Vector3.zero
      BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
      
      local BodyPosition = Instance.new("BodyPosition", RootPart)
      BodyPosition.Position = RootPart.Position
      BodyPosition.P, BodyPosition.D = 1e4, 1e3
      BodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
      
      while PlayerRootPart and RootPart and Humanoid and Humanoid.Health > 0 and Enemy do
        local Target = CachedBring[if Module.IsSuperBring then "ALL_MOBS" else EnemyName]
        
        if Target and (PlayerRootPart.Position - RootPart.Position).Magnitude <= Settings.BringDistance then
          if (RootPart.Position - Target.Position).Magnitude <= 5 then
            RootPart.CFrame = Target
          else
            BodyPosition.Position = Target.Position
          end
        end;task.wait()
      end
      
      if BodyVelocity then BodyVelocity:Destroy() end
      if BodyPosition then BodyPosition:Destroy() end
      if Enemy and Enemy:HasTag(BRING_TAG) then Enemy:RemoveTag(BRING_TAG) end
    end
    
    local function KillAura(Enemy)
      local Humanoid = Enemy:FindFirstChild("Humanoid")
      local RootPart = Enemy:FindFirstChild("HumanoidRootPart")
      
      pcall(sethiddenproperty, Player, "SimulationRadius", math.huge)
      
      if Humanoid and RootPart then
        RootPart.CanCollide = false
        RootPart.Size = Vector3.new(60, 60, 60)
        Humanoid:ChangeState(15)
        Humanoid.Health = 0
        task.wait()
        Enemy:RemoveTag(KILLAURA_TAG)
      end
    end
    
    for _, Enemy in CollectionService:GetTagged("BasicMob") do MobAdded(Enemy) end
    table.insert(Connections, CollectionService:GetInstanceAddedSignal("BasicMob"):Connect(MobAdded))
    table.insert(Connections, Enemies.ChildAdded:Connect(MobAdded))
    
    table.insert(Connections, CollectionService:GetInstanceAddedSignal(KILLAURA_TAG):Connect(KillAura))
    table.insert(Connections, CollectionService:GetInstanceAddedSignal(BRING_TAG):Connect(Bring))
  end)
  
  task.spawn(function()
    local BossesName = Module.BossesName
    local Fruits = Module.SpawnedFruits
    
    table.insert(Connections, workspace.ChildAdded:Connect(function(Part)
      if Module.IsFruit(Part) then
        table.insert(Fruits, Part)
        Part:GetPropertyChangedSignal("Parent"):Once(function()
          table.remove(Fruits, table.find(Fruits, Part))
        end)
      end
    end))
    
    for Name, _ in Module.Bosses do
      table.insert(BossesName, Name)
    end
    
    for _, Part in workspace:GetChildren() do
      if Module.IsFruit(Part) then
        table.insert(Fruits, Part)
        Part:GetPropertyChangedSignal("Parent"):Once(function()
          table.remove(Fruits, table.find(Fruits, Part))
        end)
      end
    end
  end)
  
  task.spawn(function()
    local SpawnLocations = Module.SpawnLocations
    local EnemyLocations = Module.EnemyLocations
    
    local function NewIslandAdded(Island)
      if Island.Name:find("Island") then
        Module.RaidIsland = nil
      end
    end
    
    local function NewSpawn(Part)
      local EnemyName = GetEnemyName(Part.Name)
      EnemyLocations[EnemyName] = EnemyLocations[EnemyName] or {}
      
      local EnemySpawn = Part.CFrame + Vector3.new(0, 25, 0)
      SpawnLocations[EnemyName] = Part
      
      if not table.find(EnemyLocations[EnemyName], EnemySpawn) then
        table.insert(EnemyLocations[EnemyName], EnemySpawn)
      end
    end
    
    for _, Spawn in EnemySpawns:GetChildren() do NewSpawn(Spawn) end
    table.insert(Connections, EnemySpawns.ChildAdded:Connect(NewSpawn))
    table.insert(Connections, Locations.ChildAdded:Connect(NewIslandAdded))
  end)
  
  task.spawn(function()
    function Module:GetItemCount(index: string?): number
      return self.ItemsCount[index] or 0
    end
    
    function Module:GetItemMastery(index: string?): number
      return self.ItemsMastery[index] or 0
    end
    
    function Module:UpdateItem(item: table): (nil)
      if type(item) == "table" then
        if item.Type == "Wear" then
          item.Type = "Accessory"
        end
        
        local Name = item.Name
        
        self.Inventory[Name] = item
        
        if not self.Unlocked[Name] then self.Unlocked[Name] = true end
        if item.Count then self.ItemsCount[Name] = item.Count end
        if item.Mastery then self.ItemsMastery[Name] = item.Mastery end
      end
    end
    
    function Module:RemoveItem(itemName: string): (nil)
      if type(itemName) == "string" then
        self.Unlocked[itemName] = nil
        self.Inventory[itemName] = nil
        self.ItemsCount[itemName] = nil
        self.ItemsMastery[itemName] = nil
      end
    end
    
    local function OnClientEvent(Method, ...)
      if Method == "ItemChanged" then
        Module:UpdateItem(...)
      elseif Method == "ItemAdded" then
        Module:UpdateItem(...)
      elseif Method == "ItemRemoved" then
        Module:RemoveItem(...)
      end
    end
    
    Module.ItemsMastery = {}
    Module.ItemsCount = {}
    Module.Inventory = {}
    Module.Unlocked = {}
    
    for _, Tool in ipairs(Module.FireRemote("getInventory")) do Module:UpdateItem(Tool) end
    table.insert(Connections, CommE.OnClientEvent:Connect(OnClientEvent))
  end)
  
  task.spawn(function()
    local DeathM = require(WaitChilds(ReplicatedStorage, "Effect", "Container", "Death"))
    local CameraShaker = require(WaitChilds(ReplicatedStorage, "Util", "CameraShaker"))
    
    CameraShaker:Stop()
    if hookfunction then
      hookfunction(DeathM, function(...) return ... end)
    end
  end)
  
  task.spawn(function()
    local OwnersId = { 3095250 }
    local OwnersFriends = {}
    
    local function StopFarming()
     print("ai")
    end
    
    local function OnPlayerAdded(__Player, Error)
      if __Player == Player then return end
      
      if table.find(OwnersId, __Player.UserId) or OwnersFriends[__Player.UserId] then
        return if Error then error("A-D-M-I-N", 2) else StopFarming()
      elseif WaitChilds(__Player, "Data", "Level").Value > Module.MaxLevel then
        return if Error then error("A-D-M-I-N", 2) else StopFarming()
      end
    end
    
    table.insert(Connections, Players.PlayerAdded:Connect(OnPlayerAdded))
    for _, __Player in ipairs(Players:GetPlayers()) do OnPlayerAdded(__Player, true) end
    
    for i = 1, #OwnersId do
      local Friends = Players:GetFriendsAsync(OwnersId[i])
      
      while not Friends.IsFinished do
        local FriendsList = Friends:GetCurrentPage()
        
        for i = 1, #FriendsList do
          local Friend = FriendsList[i]
          local __Player = Players:GetPlayerByUserId(Friend.Id)
          
          if __Player then
            OnPlayerAdded(__Player)
          else
            table.insert(OwnersFriends, Friend.Id)
          end
        end
        
        Friends:AdvanceToNextPageAsync()
      end
    end
  end)
  
  task.spawn(function()
    local Success, RaidModule = pcall(require, ReplicatedStorage:WaitForChild("Raids"))
    
    if not Success then
      Module.RaidList = {
        "Phoenix", "Dough", "Flame", "Ice", "Quake", "Light";
        "Dark", "Spider", "Rumble", "Magma", "Buddha", "Sand";
      }
      return nil
    end
    
    local AdvancedRaids = RaidModule.advancedRaids
    local NormalRaids = RaidModule.raids
    local RaidList = {}
    
    for i = 1, #AdvancedRaids do table.insert(RaidList, AdvancedRaids[i]) end
    for i = 1, #NormalRaids do table.insert(RaidList, NormalRaids[i]) end
    
    Module.RaidList = RaidList
  end)
  
  task.spawn(function()
    local BodyVelocity = Instance.new("BodyVelocity")
    BodyVelocity.Velocity = Vector3.zero
    BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    BodyVelocity.P = 1000
    
    if _ENV.tween_bodyvelocity then
      _ENV.tween_bodyvelocity:Destroy()
    end
    
    Module.Tween = BodyVelocity
    _ENV.tween_bodyvelocity = BodyVelocity
    
    local IsAlive = Module.IsAlive
    
    local BaseParts, CanCollideObjects, CanTouchObjects = {}, {}, {} do
      local function AddObjectToBaseParts(Object)
        if Object:IsA("BasePart") and (Object.CanCollide or Object.CanTouch) then
          table.insert(BaseParts, Object)
          
          if Object.CanCollide then CanCollideObjects[Object] = true end
          if Object.CanTouch then CanTouchObjects[Object] = true end
        end
      end
      
      local function RemoveObjectsFromBaseParts(BasePart)
        local index = table.find(BaseParts, BasePart)
        
        if index then
          table.remove(BaseParts, index)
        end
      end
      
      local function NewCharacter(Character)
        table.clear(BaseParts)
        
        for _, Object in ipairs(Character:GetDescendants()) do AddObjectToBaseParts(Object) end
        Character.DescendantAdded:Connect(AddObjectToBaseParts)
        Character.DescendantRemoving:Connect(RemoveObjectsFromBaseParts)
        
        Character:WaitForChild("Humanoid", 9e9).Died:Wait()
        table.clear(BaseParts)
      end
      
      table.insert(Connections, Player.CharacterAdded:Connect(NewCharacter))
      task.spawn(NewCharacter, Player.Character)
    end
    
    local function NoClipOnStepped(Character)
      if not IsAlive(Character) then
        return nil
      end
      
      if _ENV.OnFarm and not Player:HasTag("Teleporting") then
        Player:AddTag("Teleporting")
      elseif not _ENV.OnFarm and Player:HasTag("Teleporting") then
        Player:RemoveTag("Teleporting")
      end
      
      if _ENV.OnFarm then
        for i = 1, #BaseParts do
          local BasePart = BaseParts[i]
          local CanTouchValue = if (tick() - Module.RemoveCanTouch) <= 1 then false else true
          
          if CanTouchObjects[BasePart] and BasePart.CanTouch ~= CanTouchValue then
            BasePart.CanTouch = CanTouchValue
          end
          if CanCollideObjects[BasePart] and BasePart.CanCollide then
            BasePart.CanCollide = false
          end
        end
      elseif Character.PrimaryPart and (not Character.PrimaryPart.CanCollide or not Character.PrimaryPart.CanTouch) then
        for i = 1, #BaseParts do
          local BasePart = BaseParts[i]
          
          if CanCollideObjects[BasePart] then
            BasePart.CanCollide = true
          end
          if CanTouchObjects[BasePart] then
            BasePart.CanTouch = true
          end
        end
      end
    end
    
    local function UpdateVelocityOnStepped(Character)
      local RootPart = Character and Character:FindFirstChild("UpperTorso")
      local Humanoid = Character and Character:FindFirstChild("Humanoid")
      local BodyVelocity = _ENV.tween_bodyvelocity
      
      if _ENV.OnFarm and RootPart and Humanoid and Humanoid.Health > 0 then
        if BodyVelocity.Parent ~= RootPart then
          BodyVelocity.Parent = RootPart
        end
      else
        if BodyVelocity.Parent then
          BodyVelocity.Parent = nil
        end
      end
      
      if BodyVelocity.Velocity ~= Vector3.zero and (not Humanoid or not Humanoid.SeatPart or not _ENV.OnFarm) then
        BodyVelocity.Velocity = Vector3.zero
      end
    end
    
    table.insert(Connections, Stepped:Connect(function()
      local Character = Player.Character
      UpdateVelocityOnStepped(Character)
      NoClipOnStepped(Character)
    end))
  end)
  
  Module.Hooking = (function()
    if _ENV.rz_AimBot then
      return _ENV.rz_AimBot
    end
    
    local module = {}
    _ENV.rz_AimBot = module
    
    local Enabled = _ENV.rz_EnabledOptions;
    local IsAlive = Module.IsAlive;
    
    local TargetDebounce = 0;
    local UpdateDebounce = 0;
    local ClosestsEnemies = {};
    local Skills = ToDictionary({ "Z", "X", "C", "V", "F" });
    
    local function GetNextTarget(Mode: string, ClosestList: boolean): any?
      if (tick() - TargetDebounce) <= 2 or _ENV[Mode] then
        return if ClosestList then ClosestsEnemies else ClosestsEnemies.Closest
      end
    end
    
    local function UpdateTarget()
      local tick = tick()
      
      if (tick - TargetDebounce) <= 2 then return end
      if (tick - UpdateDebounce) <= 0.3 then return end
      if not IsAlive(Player.Character) then return end
      
      local Equipped = Player.Character:FindFirstChildOfClass("Tool")
      
      if Equipped and Equipped.ToolTip then
        table.clear(ClosestsEnemies)
        UpdateDebounce = tick
        
        local Position = Player.Character:GetPivot().Position
        local Players = Players:GetPlayers()
        local Enemies = Enemies:GetChildren()
        local Distance = if Equipped.ToolTip == "Gun" then 120 else 600
        local ClosestsDistance = if Equipped.ToolTip == "Gun" then 120 else 60
        
        for i = 1, #Players do
          local __Player = Players[i]
          local Character = __Player.Character
          
          if Player ~= __Player and CheckPlayerAlly(__Player) and IsAlive(Character) then
            local UpperTorso = Character:FindFirstChild("UpperTorso")
            local Magnitude = UpperTorso and (UpperTorso.Position - Position).Magnitude
            
            if UpperTorso and Magnitude <= ClosestsDistance then
              table.insert(ClosestsEnemies, { Character, UpperTorso })
            end
            if UpperTorso and Magnitude <= Distance then
              ClosestsEnemies.Closest = { Character, UpperTorso }
              Distance = if UpperTorso then Magnitude else Distance
            end
          end
        end
        
        if Settings.NoAimMobs then
          return nil
        end
        
        for i = 1, #Enemies do
          local Enemy = Enemies[i]
          local UpperTorso = Enemy and Enemy:FindFirstChild("UpperTorso")
          
          if UpperTorso and IsAlive(Enemy) then
            local Magnitude = (UpperTorso.Position - Position).Magnitude
            
            if Magnitude <= ClosestsDistance then
              table.insert(ClosestsEnemies, { Enemy, UpperTorso })
            end
            if Magnitude <= Distance then
              Distance, ClosestsEnemies.Closest = Magnitude, { Enemy, UpperTorso }
            end
          end
        end
      end
    end
    
    function module:SpeedBypass()
      if not _ENV._Enabled_Speed_Bypass then
        _ENV._Enabled_Speed_Bypass = true
        
        local old_newindex; old_newindex = hookmetamethod(Player, "__newindex", function(self, index, value)
          if tostring(self) == "Humanoid" and index == "WalkSpeed" then
            return old_newindex(self, "WalkSpeed", _ENV.WalkSpeedBypass or value)
          end
          return old_newindex(self, index, value)
        end)
      end
    end
    
    function module:EnableAim()
      local old_namecall; old_namecall = hookmetamethod(game, "__namecall", function(self, ...)
        local Method = string.lower(getnamecallmethod())
        
        if Method ~= "fireserver" then
          return old_namecall(self, ...)
        end
        
        local Name = self.Name
        
        if Name == "RE/ShootGunEvent" then
          local Position, Enemies = ...
          
          if typeof(Position) == "Vector3" and type(Enemies) == "table" then
            local ClosestList = GetNextTarget("AimBot_Gun", true)
            
            if ClosestList and #ClosestList > 0 then
              for i = 1, #ClosestList do
                local Part = ClosestList[i][2]
                if Part and (not Enemies[1] or (Part.Position - Enemies[1].Position).Magnitude <= 15) then
                  table.insert(Enemies, Part)
                end
              end
              
              return old_namecall(self, Enemies[1].Position, Enemies)
            end
          end
        elseif Name == "RemoteEvent" then
          local v1, v2 = ...
          
          if typeof(v1) == "Vector3" and not v2 then
            local Target = GetNextTarget("AimBot_Skills")
            
            if Target and Target[2] then
              return old_namecall(self, Target[2].Position)
            end
          elseif v1 == "TAP" and typeof(v2) == "Vector3" then
            local Target = GetNextTarget("AimBot_Tap")
            
            if Target and Target[2] then
              return old_namecall(self, "TAP", Target[2].Position)
            end
          end
        end
        
        return old_namecall(self, ...)
      end)
      
      _ENV.original_namecall = old_namecall
    end
    
    function module:SetTarget(BasePart: BasePart, Character: Model?, IsEnemy: boolean?): (nil)
      local Closest = ClosestsEnemies.Closest
      
      if IsEnemy then
        TargetDebounce = tick()
        table.clear(ClosestsEnemies)
        ClosestsEnemies.Closest = { Character, BasePart }
        
        for _, Enemy in ipairs(Module.allMobs[Character.Name]) do
          if Enemy ~= Character and Enemy:FindFirstChild("UpperTorso") then
            table.insert(ClosestsEnemies, { Enemy, Enemy.UpperTorso })
          end
        end
      elseif not Closest or Closest[2] ~= BasePart then
        ClosestsEnemies.Closest = { false, BasePart }
      end
    end
    
    table.insert(Connections, Stepped:Connect(UpdateTarget))
    module:EnableAim()
    
    return module
  end)()
  
Module.FastAttack = (function()
		local FastAttack = {
			Distance = 50,
			attackMobs = true,
			attackPlayers = true,
			Equipped = nil,
			Debounce = 0,
			ComboDebounce = 0,
			ShootDebounce = 0,
			M1Combo = 0,
			
			Overheat = {
				["Dragonstorm"] = {
					MaxOverheat = 3,
					Cooldown = 0,
					TotalOverheat = 0,
					Distance = 350,
					Shooting = false
				}
			},
			ShootsPerTarget = {
				["Dual Flintlock"] = 2
			},
			SpecialShoots = {
				["Skull Guitar"] = "TAP",
				["Bazooka"] = "Position",
				["Cannon"] = "Position",
				["Dragonstorm"] = "Overheat"
			},
			HitboxLimbs = {"RightLowerArm", "RightUpperArm", "LeftLowerArm", "LeftUpperArm", "RightHand", "LeftHand"}
		}
		
		local RE_RegisterAttack = Net:WaitForChild("RE/RegisterAttack")
		local RE_ShootGunEvent = Net:WaitForChild("RE/ShootGunEvent")
		local RE_RegisterHit = Net:WaitForChild("RE/RegisterHit")
		local Events = ReplicatedStorage:WaitForChild("Events")
		
		local SUCCESS_FLAGS, COMBAT_REMOTE_THREAD = pcall(function()
			return require(Modules.Flags).COMBAT_REMOTE_THREAD or false
		end)
		
		local SUCCESS_SHOOT, SHOOT_FUNCTION = pcall(function()
			return getupvalue(require(ReplicatedStorage.Controllers.CombatController).Attack, 9)
		end)
		
		local HIT_FUNCTION; task.defer(function()
			local PlayerScripts = Player:WaitForChild("PlayerScripts")
			local LocalScript = PlayerScripts:FindFirstChildOfClass("LocalScript")
			
			while not LocalScript do
				Player.PlayerScripts.ChildAdded:Wait()
				LocalScript = PlayerScripts:FindFirstChildOfClass("LocalScript")
			end
			
			if getsenv then
				local Success, ScriptEnv = pcall(getsenv, LocalScript)
				
				if Success and ScriptEnv then
					HIT_FUNCTION = ScriptEnv._G.SendHitsToServer
				end
			end
		end)
		
		local IsAlive = Module.IsAlive
		
		FastAttack.ShootsFunctions = {
			["Skull Guitar"] = function(self: FastAttack, Equipped: Tool, Position: Vector3)
				Events.ShootSoulGuitar:Invoke(Position) -- Equipped.RemoteEvent:FireServer("TAP", Position)
			end
		}
		
		function FastAttack:ShootInTarget(TargetPosition: Vector3): (nil)
			local Equipped = IsAlive(Player.Character) and Player.Character:FindFirstChildOfClass("Tool")
			
			if Equipped and Equipped.ToolTip == "Gun" then
				if Equipped:FindFirstChild("Cooldown") and (tick() - self.ShootDebounce) >= Equipped.Cooldown.Value then
					if self.ShootsFunctions[Equipped.Name] then
						return self.ShootsFunctions[Equipped.Name](self, Equipped, TargetPosition)
					end
					
					if SUCCESS_SHOOT and SHOOT_FUNCTION then
						local ShootType = self.SpecialShoots[Equipped.Name] or "Normal"
						
						if ShootType == "Position" or (ShootType == "TAP" and Equipped:FindFirstChild("RemoteEvent")) then
							Equipped:SetAttribute("LocalTotalShots", (Equipped:GetAttribute("LocalTotalShots") or 0) + 1)
							GunValidator:FireServer(self:GetValidator2())
							
							if ShootType == "TAP" then
								Equipped.RemoteEvent:FireServer("TAP", TargetPosition)
							else
								RE_ShootGunEvent:FireServer(TargetPosition)
							end
							
							self.ShootDebounce = tick()
						end
					else
						VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1);task.wait(0.05)
						VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1);task.wait(0.05)
						self.ShootDebounce = tick()
					end
				end
			end
		end
		
		function FastAttack:CheckStun(ToolTip: string, Character: Character, Humanoid: Humanoid): boolean
			local Stun = Character:FindFirstChild("Stun")
			local Busy = Character:FindFirstChild("Busy")
			
			if Humanoid.Sit and (ToolTip == "Sword" or ToolTip == "Melee" or ToolTip == "Gun") then
				return false
			-- elseif Stun and Stun.Value > 0 then {{ or Busy and Busy.Value }}
			--	 return false
			end
			
			return true
		end
		
		function FastAttack:Process(assert: boolean, Enemies: Folder, BladeHits: table, Position: Vector3, Distance: number): (nil)
			if not assert then return end
			
			local HitboxLimbs = self.HitboxLimbs
			local Mobs = Enemies:GetChildren()
			
			for i = 1, #Mobs do
				local Enemy = Mobs[i]
				local BasePart = Enemy:FindFirstChild(HitboxLimbs[math.random(#HitboxLimbs)]) or Enemy.PrimaryPart
				
				if not BasePart then continue end
				
				local CanAttack = Enemy.Parent == Characters and CheckPlayerAlly(Players:GetPlayerFromCharacter(Enemy))
				
				if Enemy ~= Player.Character and (Enemy.Parent ~= Characters or CanAttack) then
					if IsAlive(Enemy) and (Position - BasePart.Position).Magnitude <= Distance then
						if not self.EnemyRootPart then
							self.EnemyRootPart = BasePart
						else
							table.insert(BladeHits, { Enemy, BasePart })
						end
					end
				end
			end
		end
		
		function FastAttack:GetAllBladeHits(Character: Character, Distance: number?): (nil)
			local Position = Character:GetPivot().Position
			local BladeHits = {}
			Distance = Distance or self.Distance
			
			self:Process(self.attackMobs, Enemies, BladeHits, Position, Distance)
			self:Process(self.attackPlayers, Characters, BladeHits, Position, Distance)
			
			return BladeHits
		end
		
		function FastAttack:GetClosestEnemy(Character: Character, Distance: number?): (nil)
			local BladeHits = self:GetAllBladeHits(Character, Distance)
			
			local Distance, Closest = math.huge
			
			for i = 1, #BladeHits do
				local Magnitude = if Closest then (Closest.Position - BladeHits[i][2].Position).Magnitude else Distance
				
				if Magnitude <= Distance then
					Distance, Closest = Magnitude, BladeHits[i][2]
				end
			end
			
			return Closest
		end
		
		function FastAttack:GetGunHits(Character: Character, Distance: number?)
			local BladeHits = self:GetAllBladeHits(Character, Distance)
			local GunHits = {}
			
			for i = 1, #BladeHits do
				if not GunHits[1] or (BladeHits[i][2].Position - GunHits[1].Position).Magnitude <= 10 then
					table.insert(GunHits, BladeHits[i][2])
				end
			end
			
			return GunHits
		end
		
		function FastAttack:GetCombo(): number
			local Combo = if tick() - self.ComboDebounce <= 0.4 then self.M1Combo else 0
			Combo = if Combo >= 4 then 1 else Combo + 1
			
			self.ComboDebounce = tick()
			self.M1Combo = Combo
			
			return Combo
		end
		
		function FastAttack:UseFruitM1(Character: Character, Equipped: Tool, Combo: number): (nil)
			local Position = Character:GetPivot().Position
			local EnemyList = Enemies:GetChildren()
			
			for i = 1, #EnemyList do
				local Enemy = EnemyList[i]
				local PrimaryPart = Enemy.PrimaryPart
				if IsAlive(Enemy) and PrimaryPart and (PrimaryPart.Position - Position).Magnitude <= 50 then
					local Direction = (PrimaryPart.Position - Position).Unit
					return Equipped.LeftClickRemote:FireServer(Direction, Combo)
				end
			end
		end
		
		function FastAttack:UseNormalClick(Humanoid: Humanoid, Character: Character, Cooldown: number): (nil)
			self.EnemyRootPart = nil
			local BladeHits = self:GetAllBladeHits(Character)
			local EnemyRoot = self.EnemyRootPart
			
			if EnemyRoot then
				if SUCCESS_FLAGS and COMBAT_REMOTE_THREAD and HIT_FUNCTION then
					RE_RegisterAttack:FireServer(Cooldown)
					HIT_FUNCTION(EnemyRoot, BladeHits)
				elseif SUCCESS_FLAGS and not COMBAT_REMOTE_THREAD then
					RE_RegisterAttack:FireServer(Cooldown)
					RE_RegisterHit:FireServer(EnemyRoot, BladeHits)
				else
					EnemyRoot.Size = Vector3.one * 50
					for i = 1, #BladeHits do BladeHits[i][2].Size = Vector3.one * 50 end
					
					VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1);task.wait(0.05)
					VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
				end
			end
		end
		
		function FastAttack:GetValidator2()
			local v1 = getupvalue(SHOOT_FUNCTION, 15) -- v40, 15
			local v2 = getupvalue(SHOOT_FUNCTION, 13) -- v41, 13
			local v3 = getupvalue(SHOOT_FUNCTION, 16) -- v42, 16
			local v4 = getupvalue(SHOOT_FUNCTION, 17) -- v43, 17
			local v5 = getupvalue(SHOOT_FUNCTION, 14) -- v44, 14
			local v6 = getupvalue(SHOOT_FUNCTION, 12) -- v45, 12
			local v7 = getupvalue(SHOOT_FUNCTION, 18) -- v46, 18
			
			local v8 = v6 * v2									-- v133
			local v9 = (v5 * v2 + v6 * v1) % v3 -- v134
			
			v9 = (v9 * v3 + v8) % v4
			v5 = math.floor(v9 / v3)
			v6 = v9 - v5 * v3
			v7 = v7 + 1
			
			setupvalue(SHOOT_FUNCTION, 15, v1) -- v40, 15
			setupvalue(SHOOT_FUNCTION, 13, v2) -- v41, 13
			setupvalue(SHOOT_FUNCTION, 16, v3) -- v42, 16
			setupvalue(SHOOT_FUNCTION, 17, v4) -- v43, 17
			setupvalue(SHOOT_FUNCTION, 14, v5) -- v44, 14
			setupvalue(SHOOT_FUNCTION, 12, v6) -- v45, 12
			setupvalue(SHOOT_FUNCTION, 18, v7) -- v46, 18
			
			return math.floor(v9 / v4 * 16777215), v7
		end
		
		function FastAttack:UseGunShoot(Character, Equipped)
			if not Equipped.Enabled then return end
			
			local ShootType = self.SpecialShoots[Equipped.Name] or "Normal"
			
			if ShootType == "Normal" or ShootType == "Overheat" then
				if ShootType == "Overheat" then
					local Data = self.Overheat[Equipped.Name]
					
					if Data.Shooting then
						return nil
					end
					
					local Target = self:GetClosestEnemy(Character, Data.Distance or 100)
					
					if Target then
						Data.Shooting = true
						
						while Equipped and Equipped.Parent == Player.Character and Data.TotalOverheat < Data.MaxOverheat do
							if Target and Target.Parent and IsAlive(Target.Parent) then
								Equipped:SetAttribute("LocalTotalShots", (Equipped:GetAttribute("LocalTotalShots") or 0) + 1)
								GunValidator:FireServer(self:GetValidator2())
								RE_ShootGunEvent:FireServer(Target.Position, { Target })
								Data.TotalOverheat += task.wait(Data.Cooldown)
							else
								break
							end
						end
						
						while Data.TotalOverheat > 0 do
							Data.TotalOverheat = math.clamp(Data.TotalOverheat - task.wait(), 0, Data.MaxOverheat)
						end
						
						Data.Shooting = false
					end
				else
					local Hits = self:GetGunHits(Character, 120)
					local Target = Hits[1] and Hits[1].Position
					
					if Target then
						Equipped:SetAttribute("LocalTotalShots", (Equipped:GetAttribute("LocalTotalShots") or 0) + 1)
						GunValidator:FireServer(self:GetValidator2())
						
						for i = 1, (self.ShootsPerTarget[Equipped.Name] or 1) do
							RE_ShootGunEvent:FireServer(Target, Hits)
						end
					end
				end
			elseif ShootType == "Position" or (ShootType == "TAP" and Equipped:FindFirstChild("RemoteEvent")) then
				local Target = self:GetClosestEnemy(Character, 200)
				
				if Target then
					if self.ShootsFunctions[Equipped.Name] then
						return self.ShootsFunctions[Equipped.Name](self, Equipped, Target.Position)
					end
					
					Equipped:SetAttribute("LocalTotalShots", (Equipped:GetAttribute("LocalTotalShots") or 0) + 1)
					GunValidator:FireServer(self:GetValidator2())
					
					if ShootType == "TAP" then
						Equipped.RemoteEvent:FireServer("TAP", Target.Position)
					else
						RE_ShootGunEvent:FireServer(Target.Position)
					end
				end
			end
		end
		
		function FastAttack.attack()
			if not Settings.AutoClick or (tick() - Module.AttackCooldown) <= 1 then return end
			if not IsAlive(Player.Character) then return end
			
			local self = FastAttack
			local Character = Player.Character
			local Humanoid = Character.Humanoid
			
			local Equipped = Character:FindFirstChildOfClass("Tool")
			local ToolTip = Equipped and Equipped.ToolTip
			local ToolName = Equipped and Equipped.Name
			
			if not Equipped or (ToolTip ~= "Gun" and ToolTip ~= "Melee" and ToolTip ~= "Blox Fruit" and ToolTip ~= "Sword") then
				return nil
			end
			
			local Cooldown = Equipped:FindFirstChild("Cooldown") and Equipped.Cooldown.Value or 0.3
			
			if (tick() - self.Debounce) >= Cooldown and self:CheckStun(ToolTip, Character, Humanoid) then
				local Combo = self:GetCombo()
				Cooldown += if Combo >= 4 then 0.05 else 0
				
				self.Equipped = Equipped
				self.Debounce = if Combo >= 4 and ToolTip ~= "Gun" then (tick() + 0.05) else tick()
					
				if ToolTip == "Blox Fruit" then
					if ToolName == "Ice-Ice" or ToolName == "Light-Light" then
						return self:UseNormalClick(Humanoid, Character, Cooldown)
					elseif Equipped:FindFirstChild("LeftClickRemote") then
						return self:UseFruitM1(Character, Equipped, Combo)
					end
				elseif ToolTip == "Gun" then
					if SUCCESS_SHOOT and SHOOT_FUNCTION and Settings.AutoShoot then
						return self:UseGunShoot(Character, Equipped)
					end
				else
					return self:UseNormalClick(Humanoid, Character, Cooldown)
				end
			end
		end
		
		table.insert(Connections, Stepped:Connect(FastAttack.attack))
		
		return FastAttack
	  end)()
end

end 

return Module
return Module

